"""
Ce fichier comprend les transformations correspondant à
$F(R_{i-1},K_i)$ (permutation, S-box, etc.) appliquées au cas particulier du DES.
"""
from permutation import shift_left

"""
Dictionnaire des 8 S-BOX  (voir énoncé du projet).
"""
S_BOX_BANK = [
    [0x4, 0xA, 0x9, 0x2, 0xD, 0x8, 0x0, 0xE, 0x6, 0xB, 0x1, 0xC, 0x7, 0xF, 0x5, 0x3],
    [0xE, 0xB, 0x4, 0xC, 0x6, 0xD, 0xF, 0xA, 0x2, 0x3, 0x8, 0x1, 0x0, 0x7, 0x5, 0x9],
    [0x5, 0x8, 0x1, 0xD, 0xA, 0x3, 0x4, 0x2, 0xE, 0xF, 0xC, 0x7, 0x6, 0x0, 0x9, 0xB],
    [0x7, 0xD, 0xA, 0x1, 0x0, 0x8, 0x9, 0xF, 0xE, 0x4, 0x6, 0xC, 0xB, 0x2, 0x5, 0x3],
    [0x6, 0xC, 0x7, 0x1, 0x5, 0xF, 0xD, 0x8, 0x4, 0xA, 0x9, 0xE, 0x0, 0x3, 0xB, 0x2],
    [0x4, 0xB, 0xA, 0x0, 0x7, 0x2, 0x1, 0xD, 0x3, 0x6, 0x8, 0x5, 0x9, 0xC, 0xF, 0xE],
    [0xD, 0xB, 0x4, 0x1, 0x3, 0xF, 0x5, 0x9, 0x0, 0xA, 0xE, 0x7, 0x6, 0x8, 0x2, 0xC],
    [0x1, 0xF, 0xD, 0x0, 0x5, 0x7, 0xA, 0x4, 0x9, 0x2, 0x3, 0xE, 0x6, 0xB, 0x8, 0xC]]

S_BOX_RFC = [[0xC, 0x4, 0x6, 0x2, 0xA, 0x5, 0xB, 0x9, 0xE, 0x8, 0xD, 0x7, 0x0, 0x3, 0xF, 0x1],
             [0x6, 0x8, 0x2, 0x3, 0x9, 0xA, 0x5, 0xC, 0x1, 0xE, 0x4, 0x7, 0xB, 0xD, 0x0, 0xF],
             [0xB, 0x3, 0x5, 0x8, 0x2, 0xF, 0xA, 0xD, 0xE, 0x1, 0x7, 0x4, 0xC, 0x9, 0x6, 0x0],
             [0xC, 0x8, 0x2, 0x1, 0xD, 0x4, 0xF, 0x6, 0x7, 0x0, 0xA, 0x5, 0x3, 0xE, 0x9, 0xB],
             [0x7, 0xF, 0x5, 0xA, 0x8, 0x1, 0x6, 0xD, 0x0, 0x9, 0x3, 0xE, 0xB, 0x4, 0x2, 0xC],
             [0x5, 0xD, 0xF, 0x6, 0x9, 0x2, 0xC, 0xA, 0xB, 0x7, 0x8, 0x1, 0x4, 0x3, 0xE, 0x0],
             [0x8, 0xE, 0x2, 0x5, 0x6, 0x9, 0x1, 0xC, 0xF, 0x4, 0xB, 0x0, 0xD, 0xA, 0x3, 0x7],
             [0x1, 0x7, 0xE, 0xD, 0x0, 0x5, 0x8, 0x3, 0x4, 0xF, 0xA, 0x6, 0x9, 0xC, 0xB, 0x2]]


def apply_sbox(data, s_box):
    """
    Cette fonction applique les 8 s-box sur un entier de 32 bits et ressort l'entier de
    32bits correspondant. (voir énoncé du projet).
    Chacun des 8 groupes de 4 bits doit être remplacé en utilisant la S-BOX correspondante.
    Les 4 bits de poids le plus forts utilisent la première S-BOX, les 4 suivants la deuxième, etc.
    :param s_box: s_box utilisée, fournie sous forme de liste de liste.
        Le premier élément de la liste est utilisée pour les 4 bits les plus fort.
    :param data: Un entier de 32 bits.
    :return: L'entier de 32 bits modifié.
    """
    final_result = 0
    masque = 2 ** 4 - 1  # on crée un masque pour recupérer 4bits
    shift_value = 28

    for i in range(0, 8):
        next_4bits = (data >> shift_value) & masque
        s_box_value = s_box[i][next_4bits]  # on cherche la valeur dans chaque ligne de la sbox
        final_result |= s_box_value << shift_value  # on ajoute la valeur au resultat final
        shift_value -= 4
    return final_result


def gost_feistel_function(key, data, s_box=S_BOX_RFC):
    """
    Cette fonction applique l'ensemble des transformations consistuant la fonction de Feistel spécifique au GOST:
    - Application de l'addition modulo
    - Appliquation des S-box
    - Application du shift de 11 bits
    :param s_box: s_box utilisée sous la forme de liste de liste
    :param key: La clé de 32 bits locale au round.
    :param data: Les 32 bits de données sur lesquels appliquer la fonction de Feistel
    :return: Les 32 bits transformés suivant la fonction de Feistel
    """
    apply_mod = (data + key) % 2 ** 32
    apply_sb = apply_sbox(apply_mod, s_box)
    apply_shift = shift_left(apply_sb, 32, 11)
    return apply_shift
